## 哈希表 或是 散列表

### 定义
哈希表是一种通过哈希函数（hash function），将Key映射到特定值作为存储位置索引index，然后根据index得到value的一种数据结构，它维护键key和值value之间一一对应关系。
### 实现
实现一个哈希表也很容易，主要需要完成的工作只有三点：

* 实现哈希函数 hash function： h(key) -> index
* 冲突的解决
* 操作接口的实现

### 哈希冲突 及 解决
冲突：在映射到一个较小的空间中时可能会出现两个不同的key映射到同一个index上的情况， 这就是我们所说的出现了冲突。

#### 哈希冲突的解决
1. 分离链接法
将散列到同一个值得所有元素保存到一个链表中。

搜索：为了执行一次搜索，我们首先需要通过hash函数得到我们需要遍历的链表，然后在链表中执行一次查找。

插入：如果一个元素是一个新的元素，那么它将插入到链表的前端。这是基于这样的事实：**新插入的元素最有可能不久又被访问**

2. 开放定址法
对于发生冲突的元素，从冲突位置附近尝试另外一些单元，直到找出空的单元为止。

对于这类冲突解决的方法一般会有个 称为**装填因子**的变量，其值应该小于0.5

3. 线性探测法
线性探测法是开放定址法的一种，其尝试策略很简单，就是寻找冲突点的下一个空闲位置，直到找到空闲位置为止。

该方法在表很空的情况下（装填因子很小）也容易产生一些连续的区块，使得插入新的元素的时候需要经过多次试选才能完成，该现象被称为**一次聚集**

4. 平方探测法
这种方法是在寻找空闲单元的时候以二次方作为偏移，虽然该方法排除了一次聚集的现象，但是很明显也会出现**二次聚集**的现象。

该方法还有一个很大的缺陷，如果表的大小不是素数的时候，即使表有超过一半是空的，也有可能会出现插入新元素失败的现象。不过可以证明的是**如果表的大小是素数，而且表至少有一半是空闲的（也就是说装填因子小于0.5）那么总能保证插入一个新的元素**

5. 双散列
双散列的定义就是，在偏移的选择上面也是通过一个散列函数来选择的。

6. 再散列
当一个散列表装得太满了（装填因子太大）导致删除或插入操作耗时太长或是无法完成插入，这时需要重新建立一个大小为原来两倍的表，然后扫描原表的内容，将原表的内容映射到新表中。

### 一致性哈希



### 多阶哈希

### 布隆过滤器

### 常用hash函数
PHP中使用的是称为DJBX33A算法

 Redis 使用 MurmurHash2 算法来计算键的哈希值

### 实际使用的哈希冲突解决方法
Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 next 指针， 多个哈希表节点可以用 next 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。