## IO 多路复用

从[C10K](https://segmentfault.com/a/1190000007240744)问题说起，当单机的并发量急剧上升的时候，如何提高单价的承载能力成了我们主要研究的问题。

按照以往的做法，我们为每个连接维护一个进程或线程，然后在进程中调用阻塞的函数来等待数据准备好。这种方法会带来很严重的问题，首先进程pcb的分配对系统的内存要求较高，其次，进程间的切换和数据的拷贝会严重影响系统的响应速度，使得系统的很大一部分资源都用于系统的切换和数据的拷贝了。

这就让我们想，能不能把这部份等待的时间（阻塞）或切换轮询（非阻塞）的时间交给内核来处理，而我们用户程序只处理内核已经准备好的数据，这就引出了IO多路复用模型。、

### 想法：统一托管
试想上面那种每来一个连接都要维护一个进程的做法，我们的进程都在等待连接的数据准备好，然后将它拷贝到用户空间处理，所以系统的资源都用于等待数据准备了。

为此我们想到，我们在内核建立一个代理，这个代理接收一个描述符的集合，由它来帮我们轮询，等待由数据准备好就可以返回。为了处理多个连接我们**阻塞式**地调用这个代理，直到它返回一个已经准备好的连接的数据。这就是select系统调用的思想了。

### select
调用select告诉内核对那些描述符（就读、写或异常条件）感兴趣以及等待多长时间。感兴趣的描述符不局限于套接字，任何描述符都可以使用select来测试。

select 函数监视的文件描述符分3类，分别是readfds、writefds和exceptfds（都是值-结果参数）。调用后select函数会阻塞，直到有描述符就绪（有数据可读、可写、或者有异常）或者超时，然后函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。

#### select 的缺点
1. 当个进程能够监控的文件描述符的数量受到限制（最大为1024，由FD_SETSIZE宏定义决定，修改需要重新编译内核）
2. 每一次调用select，都需要将文件描述符set复制到内核里面，增加了系统开销
3. select采用轮询的方式，每一次内核都要遍历 [0，maxfdp1)这么多个文件描述符，即使文件描述符set里面只有一个值为maxfdp的文件描述符，而且返回的时候，程序需要遍历所有监控的文件描述符来获得可读写的文件描述符

### poll
相比于 select poll 使用指针传递而不是值传递的方式来传递参数，并且pollfd并没有最大数量限制（但是数量过大后性能也是会下降）


值得注意的是和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。

### epoll

epoll使用过回调函数来表征数据准备就绪的，因此不存在轮询fdset以寻找就绪的fd所带来的开销。

epoll使用mmap加速内核与用户空间的信息传递。epoll是通过内核与用户空间mmap同一块内存，避免了无畏的内存拷贝

epoll支持水平触发(一直通知直到被处理)和边沿触发(只通知一次，不管有没有被处理)


对于 ASIO IO 类型 复用模型使用的优先级是 IOCP EPOLL KQUEUE POLL



参考[大话 Select、Poll、Epoll](https://cloud.tencent.com/developer/article/1005481)

