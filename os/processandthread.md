## 进程与线程

### 进程
1. 进程是操作系统内存分配的基本单位，因此进程拥有一个独立的内存空间和寄存器组，而且一个进程崩溃不会影响其它进程。
2. 进程间通信（IPC）的方式通常有： 管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。
3. 进程至少有 5 种基本状态，它们是：初始态，执行态，等待状态，就绪状态，终止状态。
4. 一个没有线程的进程可以被看作是单线程的。


### 线程
1. 线程是 CPU 调度的基本单位，线程上下文切换比进程上下文切换要快得多。线程必须依赖于进程而存在，但是线程还是有自己的栈和栈指针，程序计数器等寄存器。
2. 线程间的通信：直接读写进程数据段（如全局变量）来进行通信，需要通过 进程同步 和 互斥量 的手段来保证在并发条件下的数据一致性的问题。
3. 线程有 3 个基本状态：就绪，执行，阻塞。 线程存在 5 种基本操作来切换线程的状态：派生，阻塞，激活，调度，结束。



### 进程创建 fork

fork()函数一次调用两次返回，对于子进程它返回0，对于父进程它返回子进程的pid。
fork()在子进程需要装载父进程的内存的拷贝时 触发 内存分配，系统会为其分配和父进程相同的内存空间。
fork()还会复制父进程的文件描述符，exec也会保留调用它的进程的文件描述符。fork()不会复制文件描述符偏移，因此文件描述符偏移在父子进程之间是共享的（这一点和dup也是一样的：只复制文件描述符而不复制文件描述符偏移）。

所以就有了IO重定向的思路： fork一个进程，子进程关闭标准输入文件描述符，子进程打开目的IO，exec替换子进程 这样 exec运行的进程 就关联了 替换了 标准输入输出 的 目的IO。


### 孤儿进程
孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

没有父进程的孤儿进程会被0号进程收养，因此孤儿进程是无害的。

### 僵尸进程
僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。

僵尸进程的解决方法：
  1. 通过信号机制。子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。
  2. fork两次。 将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。

### 管道
管道与普通的IO相比有三个优点： 数据长度任意 自我清扫 允许同步

同步的实现是：两个进程通过管道来进行信息的传递，其中一个进程对管道进行读，然后被阻塞，知道另一个进程对同一对管道进行写的时候才会消除之前进程的阻塞，这就实现了进程间的同步。








