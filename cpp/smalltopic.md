## C++ 语言细节

### 负数取余

假设 `y = ax + b` 其中y是除数，x是被除数，a是商，b是余数
记住一点就是：b 应该与 a 同号，也就是说，余数永远和被除数同号
    -5 = -1 * 3 + -2 
    -5 = 1 * -3 + -2

这样就能得到对应的商和余数了，不管被除数是正还是负

### 字节序与数据类型存储
#### 字节序
字节序分为大小端，注意这里指的是字节的顺序，再往细分就不关注了，也就是说如果 0x11223344 的一个值在内存中以 低地址 存放 11 高地址存放 44，那么就是大端。
如果是高地址存放 11 低地址存放 44 那就是小端。

计算机处理字节序的时候，不知道什么是高位字节，什么是低位字节。它只知道按顺序读取字节，先读第一个字节，再读第二个字节。

如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序正好相反。

#### 位段

#### 整形存储
整形

一个小例子：

``` c
int a = 65;
char *s = (char *)(&a);
printf("%s",s);
```
这里会输出A，代码虽然少，但是考点很多，一个是整型的存储，一个是大小端，一个是%s 的结束符，首先是整型的存储，对于整数，它的补码等于原码，所以 65 的存储是 0x00021;
然后是字节序，明显s指向的是a的低地址的数据，因为是小端32位，所以指向的也就是a的最低有效位的数据 0x65，然后后面是 0x00（结束符），所以会输出65为ASCII码的字符后遇到结束符然后就退出了。

#### 浮点型存储

### 数组做参数退化成指针 求其大小
很明显，如果使用数组名作为形参，会退化为指针进行传值，如何解决这个问题。

例如下面的代码：
``` cpp
void arrFun(char a[])
{
    cout<<sizeof(a)<<endl;
}

void arrRefFun(auto &a)
{
    cout<<sizeof(a)<<endl;
}

template <unsigned N>
void arrTemplateFun(const char (&a)[N])
{
    cout<<N<<endl;
}

int main(int argc, char *argv[])
{

    char a[10] = "abcd";
    char *b = new char[10] ();

    arrFun(a);// 4
    arrRefFun(a);// 10
    arrTemplateFun("abcd");// 5
    arrTemplateFun(a);// 10

    arrFun(b);// 4
    arrRefFun(b);// 4
    //arrTemplateFun(b);// 错误用法，不能实例化模板

    return 0;
}
```

其中第一种方式就是使用的是数组名传参，可以看到输出的是指针的大小为4byte，数组的维度信息丢失了

第二种方式使用新标准的auto的方式，得到的类型就是实参的类型，也就是说，如果又两个 数组 char a[10] char b[20] 使用auto对两者进行类型推断得到的两种类型是不一样的，一个是 维度为10 的数组，一个是维度是20的数组

第三种方式是通过非类型模板的形式进行模板实例化，这种方式有限制，只有维度是字面值，可以推断出N 的大小的形式才能使用，不过对于解决这个问题这种限制可以忽略。也就是说我们不能使用一个 `普通局部变量` 或 `动态对象` 作为 `指针` 或 `引用`  的 `非类型模板参数` 的 `实参`。
