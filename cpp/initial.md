## 初始化

### 说明
对于一种初始化形式，我们说它属于哪种初始化方式，指的是它最表层看出来的初始化方式，也就是说它的类型可以变成其它类型，但是其初始化的方式还是不会变。

而对于给定的形式，可能该形式会根据类型的不一样（包括是否内置类型，构造函数的定义等）而属于其它的初始化方式，甚至，有的会执行两次初始化。但这些都不会影响最表层的初始化方式。

### 默认初始化 {#defaultInit}
这是在不使用初始化器构造变量时执行的初始化。形式为：

``` cpp
T object ;
new T ;
```

#### 在以下情况下发生默认初始化：
* 拥有`自动`、`静态`或`线程局域存储期`的变量声明不带初始化器时；
* 基类或非静态数据成员未在构造函数初始化器列表提及，且调用了该构造函数时。

#### 默认初始化的方式为：
* 若 T 是数组类型，则每个数组元素都被默认初始化；

 ``` cpp
 T t[10];//对于每个t都是执行默认初始化
 ```

* 若T是类类型（如string或其他自定义类型），不管定义于何处，都会执行默认构造函数。如果该类没有默认构造函数（隐式产生的也算）比如构造函数为delete，则会引发错误。如果要定义const T 类类型的变量，则构造函数必须是由用户显式提供（不能是默认生成的）

 ``` cpp
 class T
 {
 public:
     T()=delete;
 private:
     int member1;
 };
 class A
 {
 private:
     int member1;
 };
 int main()
 {
    T t; // 错误用法，没有默认构造函数
    A a; // 正确用法，a执行默认初始化，调用隐式生成的默认构造函数，对于其成员`未在构造函数初始化器列表提及`也是执行默认初始化， 其值不确定
    const A a; // 错误用法，const 类型，用户没有显式提供构造函数
 }
 ```

* 对于非类类型，如果是`静态` `线程局域(包括了全局)` 变量将先进行[零初始化](#zeroInit)，否则其值未确定。

 ``` cpp
 int x1; // 零初始化为 0 然后默认初始化不做任何事
 std::string s; // 零初始化为不确定值 再默认初始化为 ""
 int main()
 {
    static int x2; // 零初始化为0 然后默认初始化不做任何事
    int x3; // 未进行初始化，其值不确定
 }
 ```


### 值初始化 {#valueInit}
变量以空初始化器构造时进行的初始化。具体有以下几种形式：

``` cpp
T();	       
new T ();	
Class::Class(...) : member() { ... }	
T object {};	
new T {};	
Class::Class(...) : member{} { ... }	
```

注意 `T object();`是函数声明而非值初始化。

#### 值初始化方式为：
* 若 T 是数组类型，则数组的每个元素都被值初始化；
``` cpp
    new T[3](); // 数组每个元素执行值初始化
    std::vector<int> v(3);  // 值初始化每个元素 每个元素（int类型）的值为 0
```
* 所有情况下，若使用空花括号对 {} 且 T 是聚合类型，则进行聚合初始化而非值初始化。
* 若 T 是 `无默认构造函数` 或 `拥有用户提供默认构造函数` 或 `删除的构造函数` 的类类型，则[默认初始化对象](#defaultInit)
* 若 T 是 拥有默认构造函数的类类型，而默认构造函数既非用户提供亦非被删除（即它可以是拥有隐式定义或默认的默认构造函数），则先零初始化，然后若有`非平凡的默认构造函数`则默认初始化对象；

以上几种情况举例如下：

``` cpp
#include <iostream>

using namespace std;

class A
{
    
public:
    int member1;
    
};

class B
{
    
public:
    int member1;
    B(const B& b){} // 只有复制构造函数，无默认构造函数
    
};

class C
{
    
public:
    int member1;
    C()=delete; // 默认构造函数为删除
    
};
class D
{
    
public:
    int member1;
    D(){} // 用户提供的默认构造函数
    
};

class PA
{
public:
    A a;
    PA(int k):a(){} // 值初始化a
    PA():a{}{} // 值初始化a
};


int main(int argc, char *argv[])
{   
    A(); // 值初始化
    A{}; // 值初始化
    A a{}; // 值初始化
    new A(); // 值初始化
    new A{}; // 值初始化
    
    cout<<C{}.member1<<endl; // 使用空花括号对 {} 且 T 是聚合类型，则进行聚合初始化而非值初始化。 初始化member1 为零
    
    // 以下为值初始化
    cout<<A().member1<<endl; // 用法正确 隐式构造函数，则零初始化 member1 为零
    cout<<B().member1<<endl; // 用法错误 无默认构造函数，只有复制构造函数，执行默认初始化，默认初始化发现没有默认构造函数 所以出错
    cout<<C().member1<<endl; // 用法错误 默认构造函数为删除，执行默认初始化，默认初始化发现没有默认构造函数 所以出错
    cout<<D().member1<<endl; // 用法正确 用户提供的默认构造函数，执行默认初始化，member1也是默认初始化 其值不确定

    return 0;
}

```

* 否则，对象被[零初始化](#zeroInit)

#### 聚合类
聚合类是一种没有用户定义的构造函数，没有私有（private）和保护（protected）非静态数据成员，没有基类，没有虚函数。其实就是只有成员变量的结构体。


### 直接初始化 {#directInit}
以调用构造函数的形式显示初始化对象



### 零初始化 {#zeroInit}
设置对象的初始值为零，主要由以下的几种形式：

``` cpp
static T object ;	

T () ;
T t = {} ; 
T {} ;

char array [ n ] = "";	
```

#### 在以下几种方式触发零初始化
*  对于每个拥有静态或线程局域存储期的具名变量，零初始化在其他任何初始化之前进行。
* 当字符数组以较短的字符串字面量初始化时，数组剩余部分被零初始化。
* 作为 `非类类型 的 值初始化序列`(包含`未提供初始化器的聚合体元素 的 值初始化`) 和 `无默认构造函数的类类型成员 的 值初始化序列` 的一部分，


#### 零初始化的方式
零初始化的效果是：

若 T 是标量类型类型，则对象初值为显式转换到 T 的整数零。
若 T 是非联合体类类型，则所有基类和非静态数据成员别零初始化，且所有填充位被初始化为零位。忽略构造函数，若它存在。
若 T 是联合体类型，则首个具名非静态数据成员被零初始化且所有填充位被初始化到零位。
若 T 是数组类型，则每个元素都被零初始化
若 T 是引用类型，则不做任何事。


```


Copy initialization

Aggregate initialization
List initialization(C++11)
Reference initialization
Static non-local initialization 
 zero - constant
Dynamic non-local initialization
 ordered - unordered
```