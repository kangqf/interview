### C++ 基础 {#basic}

1. 除了 `cin` `cout` 之外，标准库还定义了 `cerr` `clog` 用来输出错误警告信息和日志信息。
2. `<<` 运算符返回其左侧运算对象。
3. `program <infile >outfile` 用于将标准输入与输出与特定的命名文件关联。
4. 一般来说 float 是4个byte，而 double 是8个byte，分别对应着 7个有效位和16个有效位。
5. 如果表达式中既有无符号类型又有带符号类型，那么带符号类型会转换成无符号类型，例如
```
unsigned int a = 1;
int b = -1; 
auto c = a*b;//等价于 unsigned int c = a * (unsigned int)b;
```
6. 以0开头的是八进制，0x开头的是十六进制。`\1234` == `char a = 0123;char b = 4;` `\x1234` == `char a = 0x1234;`
7. 无论是初始化或者赋值都可以使用花括号包含的形式，对于初始化，这种方式被称为列表初始化，当使用列表初始化且初始值存在丢失信息的风险时，编译器将报错。
8. 定义变量的时候没有指定初始值，则将会被执行默认初始化，其方式受到变量的类型和位置共同决定：
```
内置类型存在于任何函数体之外： 执行零初始化，被初始化为0。
内置类型存在于函数体内部：不被初始化
对于类类型：执行默认构造函数
```
9. 为了支持分离式编译，C++将声明与定义区分开来，对于声明，只是告诉编译器该名字的存在，而定义则是定义该名字的真正实体。
```
filea: int a = 0;
fileb: extern int a; // 为了使用文件a中的变量必须使用声明
extern int a = 0; // 包含初始值的声明就成了定义
声明可以在不同的文件里面重复声明，而定义不能重复定义
```
10. C++的标识符是以字母、数字、下划线组成不能以数字开头。为了防止与C++标准库冲突，用户自定义的标识符不能以下划线紧连着大写字母开头也不能出现两个连续的下划线，函数体外的标识符不能以下划线开头。
11. 一条声明语句由一个数据类型和紧随其后的一个声明符列表组成，每个声明符命令了一个变量，并指定该变量与基本数据类型有关的某种类型（引用或指针）。
12. 引用必须初始化，但引用不是对象，因此不能定义引用的引用，引用只能绑定到对象上而不能与字面值或某个表达式的计算结果绑定在一起（常量的引用可以用表达式作为初始值，只要该表达式的结果能够转换为引用的类型即可）。
13. 空指针nullptr为C++11标准的特殊类型的字面值，而NULL则是则是预处理变量（宏）。
14. 声明符由修饰符与变量标识符组成，在定义多个变量时通常将修饰符与变量标识符写在一起：`int **pp, *p, k, *&p=p`。
15. const对象一旦创建就不能改变因此其必须初始化。
16. 常量表达式**constexpr**是指不会改变(由类型修饰符决定)并且在编译过程就能得到(由初始值决定)计算结果的表达式：`constexpr int x = y+1;`，常量属于常量表达式的一种。常量保证了类型声明符，当时没有保证初始值，而constexpr会限制初始值也是一个常量表达式，否则会报错。例如fun不是一个常量表达式`const x = fun();`不报错而`constexpr y = fun()`则会报错，因为初始值不是常量表达式。constexpr 函数通常隐式都是内联的，而且一个函数是不是constexpr函数还与其参数有关。
17. 类型别名`typedef int arrT[10]` == `using arrT = int[10]`
18. auto 通过初始值来推算变量类型，因此auto定义的变量必须有初始值，auto会忽略顶层const，auto还会忽略引用类型并返回引用所指向的真实的类型。
19. decltype 选择并返回操作数的数据类型，编译器只分析表达式的类型却不实际计算表达式的值，其可以识别顶层与底层const，也可以返回引用。对于decltype 使用的操作数来说，如果不加括号，那么就把它当做普通变量，得到的结果就是该变量的类型；如果加上括号，就把它当做一个表达式，也就是说如果对一个变量加上了括号就会将其当做是可以作为赋值语句左值的特殊表达式，就是引用类型：`int i = 0; decltype( (i) ) r = i`r就是引用类型。
20. 类体后面可以紧随变量名来表示对该类型变量的定义，所以花括号后面的分号必不可少。
21. 头文件中不应该包含using声明以防止不经意的名字冲突。
22. 使用等号初始化一个变量被称为拷贝初始化，而直接调用构造函数形式的初始化被称为直接初始化。
23. 在执行读取操作时，string对象会自动忽略开头的空白（空格，换行，制表）并从第一个真正的字符读起。
24. 为了得到输入流中的空格，可以使用getline来代替>>操作符，getline的参数是一个输入流和一个string对象，函数会从输入流中读入内容直到遇到换行符为止（注意换行符也被读进去了但是换行不会存入到string对象中）:
```
string line;
while(getline(cin,line)
    cout<<line<<endl;
// 重新处理输入的方式
#include <sstream>
istringstream input;
input.str(line);
string str;
while(input>>str)
    cout<<str;
```
25. `int arr[10]; auto auarr(arr); decltype(arr) dearr;` 其中auarr是一个指针类型，而dearr是10维数组类型。也就是说auto操作会发生类型转换，而decltype则不会。
26. 内置类型的下标运算符使用的索引值不是无符号类型，而可以是负数，但是千万要注意越界的问题。
27. 为了实现对二维数组的range-for 对第一维的for循环遍历应该是引用形式，这可以防止数组被自动转换为指针。
28. 当一个对象被用作右值的时候用的是对象的值，而用于左值的时候用的是对象的身份，对于右值可以使用左值来代替，而反过来不行。
29. 对于左值对象使用decltype()会返回引用类型。例如 `int *p;decltype(*p);`的结果是int &。
30. 赋值运算符满足右结合律，例如`i=j=0;`会先对j赋值为0，再为i赋值为j的值。
31. sizeof 不会把数组名当成指针来处理，也就是说sizeof会得到整个数组所占空间的大小。
32. 如果无符号类型的大小等于带符号的类型的大小，那么带符号类型将会转换为无符号类型进行运算。
33. 数组名不会转为指针的几种情况，decltype & sizeof typeid 这四种情况。
34. 强制类型转换 `cast-name<type> (expression)` cast-name 是 `static_cast` `dynamic_cast` `const_cast` `reinterpret_cast` 四种，其中`static_cast` 适用于具有明确定义的类型转换，并且只要不包含底层const都可以使用，例如将较大的算术类型赋值给较小的算术类型。`const_cast` 用于将常量对象转换为非常量对象的行为。`reinterpret_cast` 用于为运算对象的位模式提供较低层次的重新解释，例如将`int * `转 `char *`，也就是说不会对数据的二进制位进行诸如类型检查数组越界的检测，例如`float a = 1.5`而`static_cast<int>(x)`只会读取a中的部分位，而`reinterpret_cast<int *>(&x)`则不会`reinterpret_cast`一般用于指针，对于不能转换的会编译出错。`dynamic_cast`用于通常含有虚函数类类型的父类与子类的指针，左值引用，或右值引用的类型转换，对于指针转换失败会返回空指针，而引用类型则抛出`bad_cast`异常。
35. 局部静态变量没有显示初始值的话会执行值初始化，内置类型将执行零初始化为0。
36. 函数的三要素：返回类型，函数名，参数类型，描述了函数的接口，说明了调用该函数所需要的全部信息。
37. 实参初始化形参时会忽略掉顶层const，当形参有顶层const修饰时`void fun(const int x);`，传给对象的实参可以是const或非const，因为const也会被忽略。同时形参是否是const无法区分函数重载`void fun(int x);`与前面的函数一样不能区分，因为如果传入一个 int 或 const int 两个函数都能够适配引发二义性。
38. 参数可变函数，一种实现的方法是让参数类型为 `initializer_list<T>` 类型来适配相同类型的多个参数，对于不同类型的参数，则需要使用可变参数模板来实现。还有一种实现方式就是省略符形参`void fun(int first, ...)`其中逗号可以省略，这个是c语言里面可变参数函数的实现方法，具体参考[C 可变参数函数](../inputandoutputinc.md#varargs)。
39. 不要返回局部对象的引用或指针，因为它所指向的对象可能不再有定义。调用一个返回引用的函数得到左值，其他返回类型返回右值。
40. 列表化返回值，例如一个返回`vector<int>`类型的函数可以返回一个花括号包围的值得列表。例如 `return {1,2,a,b};列表化返回值，例如一个返回`vector<int>`类型的函数可以返回一个花括号包围的值得列表。例如 `return {1,2,a,b};`。
41. 返回数组的指针， `using arrP = int[10];` `typedef int arrP[10];` 两种方式定义数组的别名。然后可以使用`arrP * fun(int x);`来声明一个函数，来实现返回数组的指针的目的。同样的实现可以是 ` int (*fun(int x))[10]; ` 或者是 `auto fun(int x) -> int(*)[10]` 这种方式被称为尾置返回类型。
42.  
